import { GoogleGenAI } from "@google/genai";
import { MODEL_NAME } from '../constants';
import { UpscaleResolution } from '../types';

interface AIStudio {
  hasSelectedApiKey: () => Promise<boolean>;
  openSelectKey: () => Promise<void>;
}

export const getGeminiClient = (): GoogleGenAI => {
  // Ensure we get the fresh key from process.env which is populated by the window.aistudio selector
  const apiKey = process.env.API_KEY || '';
  return new GoogleGenAI({ apiKey });
};

const getAIStudio = (): AIStudio | undefined => {
  return (window as any).aistudio;
};

export const checkApiKey = async (): Promise<boolean> => {
  const aistudio = getAIStudio();
  if (aistudio && typeof aistudio.hasSelectedApiKey === 'function') {
    return await aistudio.hasSelectedApiKey();
  }
  return false;
};

export const promptApiKeySelection = async (): Promise<void> => {
  const aistudio = getAIStudio();
  if (aistudio && typeof aistudio.openSelectKey === 'function') {
    await aistudio.openSelectKey();
  } else {
    console.warn("AI Studio key selector not available in this environment.");
  }
};

export const upscaleImage = async (
  base64Image: string, 
  resolution: UpscaleResolution
): Promise<string> => {
  const client = getGeminiClient();

  // Gemini currently supports up to 4K output generation explicitly.
  // We map the user's "Upscale" request to the closest valid API parameter.
  // 8K and 16K will use the highest available model setting (4K) but we treat the prompt differently to encourage density.
  
  let targetSize = "2K";
  if (resolution === UpscaleResolution.Res4K || resolution === UpscaleResolution.Res8K || resolution === UpscaleResolution.Res16K) {
    targetSize = "4K";
  }

  const promptText = resolution === UpscaleResolution.Res16K 
    ? "Generate a hyper-realistic, extremely high-resolution version of this image. Maximize clarity, sharpness, and texture details." 
    : "Enhance the quality of this image to high resolution. Improve details and sharpness.";

  // Clean the base64 string if it has a prefix
  const cleanBase64 = base64Image.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');
  
  try {
    const response = await client.models.generateContent({
      model: MODEL_NAME,
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: 'image/png', // Assuming PNG for high quality
            },
          },
          {
            text: promptText,
          },
        ],
      },
      config: {
        imageConfig: {
          imageSize: targetSize, // "1K", "2K", "4K"
          aspectRatio: "1:1", // Defaulting to 1:1 as aspect ratio preservation is tricky without complex cropping logic
        },
      },
    });

    // Extract the image from the response
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }
    
    throw new Error("No image generated by the model.");

  } catch (error) {
    console.error("Upscale error:", error);
    throw error;
  }
};

export const convertBlobToBase64 = (blob: Blob): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = reject;
    reader.onload = () => {
      resolve(reader.result as string);
    };
    reader.readAsDataURL(blob);
  });
};